1. 정렬 알고리즘 (7개)
	1) 버블 정렬 : 두 인접한 원소를 검사하여 정렬하는 방법이다.
		시간 복잡도 : O(n^2)
		최악의 경우 : 입력자료가 역순으로 정렬되어 있는 경우 O(n^2)
		최적의 경우 : 입력자료가 정렬되어 있는 경우 O(n^2)


	2) 삽입 정렬 : 
  자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.
		시간복잡도 : O(n^2)
		최악의 경우 : 입력자료가 역순으로 정렬되어 있는 경우 O(n^2)
		최적의 경우 : 입력자료가 정렬되어 있는 경우 O(n)


	3) 선택 정렬 : 
  주어진 배열 중에서 최솟값을 찾는다.
그 값을 맨 앞에 위치한 값과 교체한다.
맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다.

		시간복잡도 : O(n^2)
		최악의 경우 : 없다 O(n^2)
		최적의 경우 : 없다 O(n^2)


	4) 퀵 정렬 : 
  리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)
피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
분할된 부분 리스트에 대하여 순환 호출 을 이용하여 정렬을 반복한다.
부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
리스트의 크기가 0이나 1이 될 때까지 반복한다.

		시간복잡도 : O(nlog2n)
		최악의 경우 : 리스트가 계속 불균형하게 나누어지는 경우 (특히, 이미 정렬된 리스트에 대하여 퀵 				정렬을 실행하는 경우) O(n^2)
		최적의 경우 : 리스트가 계속 균형적으로 나누어지는 경우 O(nlog2n)


	5) 합병 정렬 : 
  리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.
		
		시간복잡도 : O(nlog2n)
		최악의 경우 : 없다 O(nlog2n)
		최적의 경우 : 없다 O(nlog2n)

6) 기수 정렬 :
1. 1의 자릿수를 보면서 각각의 버킷에 알맞게 담아준다. 버킷에서 순차적으로 뺀다면 1의 자릿수에 맞게 정렬이된다.
2. 1)에 의해서 정렬된 배열에서, 10의 자릿수를 비교해서 버킷에 담고 순차적으로 빼준다.
3. 2)에 의해서 정렬된 배열에서, 100의 자릿수를 비교해서 버킷에 담고 순차적으로 빼준다.
4. 최대 자릿수까지 계속해서 반복한다
[LSD]

		시간복잡도 : O(dn)(d는 가장 큰 숫자의 자릿수)
		최악의 경우 : 없음 O(dn)
		최적의 경우 : 없음 O(dn)


7) 쉘 정렬 :
먼저 정렬해야 할 리스트를 일정한 기준에 따라 분류
연속적이지 않은 여러 개의 부분 리스트를 생성
각 부분 리스트를 삽입 정렬을 이용하여 정렬
모든 부분 리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 후에 알고리즘을 반복
위의 과정을 부분 리스트의 개수가 1이 될 때까지 반복

		시간복잡도 : O(n^1.5)
		최악의 경우 : O(n^2)
		최적의 경우 : O(n)


2. 탐색 알고리즘 (2개)


	1) 이진 탐색
정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이다. 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 채택하고 있다. 처음 선택한 중앙값이 만약 찾는 값보다 크면 그 값은 새로운 최댓값이 되며, 작으면 그 값은 새로운 최솟값이 된다. 검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점이 있지만, 검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빠르다는 장점이 있다.

	2) 순차 탐색
리스트에서 특정한 값의 위치를 찾는 알고리즘의 하나다. 이것은 리스트에서 찾고자 하는 값을 맨 앞에서부터 끝까지 차례대로 찾아 나가는 것이다. 검색할 리스트의 길이가 길면 비효율적이지만, 검색 방법 중 가장 단순하여 구현이 쉽고 정렬되지 않은 리스트에서도 사용할 수 있다는 장점이 있다.
